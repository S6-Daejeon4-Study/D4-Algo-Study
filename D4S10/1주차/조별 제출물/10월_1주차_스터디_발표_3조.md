# **10월 1주차 스터디 - 3C**

**발표일자** : 2021년 10월 8일 금요일 21:00~ 22:00  
**목차**
- [발표](#발표)

  - [김응철](#김응철)
  - [김중재](#김중재)
  - [정은이](#정은이)
  - [황승연](#황승연) 
 
- [스터디사진](#스터디-사진)  
- [오픈카톡방폭파](#오픈-카톡방-폭파)
---

**알고리즘 문제 ( 기출 + 복습)**

- 기출
    - [백준 마법사 상어와 블리자드 골드2](https://www.acmicpc.net/problem/21611) - 김응철 , [황승연](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B0%B1%EC%A4%80%2021611%20%EB%A7%88%EB%B2%95%EC%82%AC%20%EC%83%81%EC%96%B4%EC%99%80%20%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C/B21611_%EB%A7%88%EB%B2%95%EC%82%AC%EC%83%81%EC%96%B4%EC%99%80%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
    - [프로그래머스 가장 긴 팬린드롬 레벨 3](https://www.notion.so/eunieuli/%20https://programmers.co.kr/learn/courses/30/lessons/12904) - [김중재](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%2012904%20%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/P12904_%EA%B0%80%EC%9E%A5%EA%B8%B4%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC_%EA%B9%80%EC%A4%91%EC%9E%AC.java), [정은이](https://www.notion.so/eunieuli/%20%5BP12904_%EA%B0%80%EC%9E%A5%EA%B8%B4%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC_%EC%A0%95%EC%9D%80%EC%9D%B4.java%5D(https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%2012904%20%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/P12904_%EA%B0%80%EC%9E%A5%EA%B8%B4%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC_%EC%A0%95%EC%9D%80%EC%9D%B4.java))
- 복습
    - 김응철
        - [백준 10026 적록색약](https://www.acmicpc.net/problem/10026) - [B10026*적록색약*김응철.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B10026_%EC%A0%81%EB%A1%9D%EC%83%89%EC%95%BD_%EA%B9%80%EC%9D%91%EC%B2%A0.java)
    - 김중재
        - [백준 1759 암호만들기](https://www.acmicpc.net/problem/1759) - [B1759*암호만들기*김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B1759_%EC%95%94%ED%98%B8%EB%A7%8C%EB%93%A4%EA%B8%B0_%EA%B9%80%EC%A4%91%EC%9E%AC.java)
        - [SWEA 5215 햄버거 다이어트](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=5215&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S5215*햄버거다이어트*김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S5215_%ED%96%84%EB%B2%84%EA%B1%B0%EB%8B%A4%EC%9D%B4%EC%96%B4%ED%8A%B8_%EA%B9%80%EC%A4%91%EC%9E%AC.java)
    - 황승연
        - [SWEA 1210 사다리](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=1210&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S1210*사다리*황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S1210_%EC%82%AC%EB%8B%A4%EB%A6%AC_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
        - [SWEA 1218 괄호짝짓기](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=1218&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S1218*괄호짝짓기*황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S1218_%EA%B4%84%ED%98%B8%EC%A7%9D%EC%A7%93%EA%B8%B0_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
    - 정은이
        - [백준 3109 빵집](https://www.acmicpc.net/problem/3109) - [B3109*빵집*정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B3109_%EB%B9%B5%EC%A7%91_%EC%A0%95%EC%9D%80%EC%9D%B4.java)

---

# **발표**

### **김응철**

- 백준 마법사 상어와 블리자드 골드2
    
    문제풀이 계획
    
- 백준 10026 적록색약 - [B10026*적록색약*김응철.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B10026_%EC%A0%81%EB%A1%9D%EC%83%89%EC%95%BD_%EA%B9%80%EC%9D%91%EC%B2%A0.java)
    
    < 이전 풀이> 
    한달전쯤에 find union 을 이용하여 시도했다가 실패했던 문제입니다
    모두가 각자의 부모인 parent 이차원배열을 만들어서
    이중 for 문으로 배열을 탐색하다 visit 하지 않은 칸을 만나면 그곳을 parents 로 시작하여 주변에 입력값이 같은 배열요소들을 find 하여 union 시키는 방식이었습니다.
    테스트케이스는 나왔지만 백준에서 돌렸을 땐 계속해서 실패했었어서 다음을 기약했는데 이번에 다른 방식으로 풀어봤습니다.
    
    < 이번 풀이 >
    이중 for 문을 돌면서 map 배열을 탐색하는 것은 같지만
    point 객체를 이용하여 v isit 하지 않은 곳부터 bfs 로 탐색하며 visit 체크를 해준다는 점이 다릅니다
    bfs 를 이용하여 풀이하니 보다 직관적이고 복잡하지 않게 코드를 짤 수 있어서 좋았습니다.
    

### **김중재**

- 프로그래머스 가장 긴 팬린드롬 레벨 3 - [P12904*가장긴팰린드롬*김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%2012904%20%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/P12904_%EA%B0%80%EC%9E%A5%EA%B8%B4%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC_%EA%B9%80%EC%A4%91%EC%9E%AC.java)
    
    문제 풀이 컨셉
    
    1. 재귀로 접근
    2. 가운데 기준으로 하는거(길이가 홀수인 팰린드롬)랑 아닌거(길이가 짝수인 팰린드롬)랑 나누기.
    3. 0번쨰 인덱스부터 크기(size)-1 까지 돌면서 홀수인 경우 짝수인 경우 중 큰거로 answer 업데이트
    4. answer 출력
    
    맨 처음 "abba" 의 경우를 생각 못하고
    테스트케이스 처럼 가운데 기준으로 앞뒤가 같은것만 갯수 세고 있었음
    
    ```
    public class Programmers_가장긴팰린드롬 {
        static char[] str;
        static int cnt;
    
        public static void main(String[] args) {
            System.out.println(solution("abba"));
        }
    
        public static int solution(String s)
        {
            int answer = Integer.MIN_VALUE;
            if(s.length() == 1) {
                return 1;
            }
            str = s.toCharArray();
    
            for(int i=0;i<str.length-1;i++) {
                cnt = 0;
                answer = Math.max(answer, check(i-1,i+1) * 2 +1);
                cnt = 0;
                answer = Math.max(answer, check(i,i+1) * 2);
            }
    
            return answer;
        }
    
        private static int check(int bNum, int nNum) {
            if(bNum == -1 || nNum == str.length || str[bNum] != str[nNum])
                return cnt;
            cnt++;
            check(bNum-1,nNum+1);
            return cnt;
        }
    }
    ```
    
- 백준 1759 암호만들기 - [B1759*암호만들기*김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B1759_%EC%95%94%ED%98%B8%EB%A7%8C%EB%93%A4%EA%B8%B0_%EA%B9%80%EC%A4%91%EC%9E%AC.java)
    
    로직
    
    1. 오름차순 정렬 후 조합의 경우의 수를 구해서 문제에서 제시한 조건에 부합하는지 확인
    a. 모음의 수를 카운트함. → contains함수 사용
    b. 모음의 수가 1이상이고 L-모음의 수가 2이상인지 확인
    2. 조건에 부합하면 해당하는 경우를 출력
    
    ```
    package month10.study.week1;
    
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.Arrays;
    import java.util.StringTokenizer;
    
    public class BOJ_1759_암호만들기 {
        static int L,C;
        static char[] arr;
        static boolean[] check;
        static String str = "aeiou";
    
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            StringTokenizer st = new StringTokenizer(br.readLine()," ");
            L = Integer.parseInt(st.nextToken());
            C = Integer.parseInt(st.nextToken());
            arr = new char[C];
            check = new boolean[C];
    
            st = new StringTokenizer(br.readLine()," ");
            for(int i=0;i<C;i++) {
                arr[i] = st.nextToken().charAt(0);
            }
            // 입력 완료
    
            Arrays.sort(arr);
    
            comb(0,0);
        }
    
        private static void comb(int target, int cnt) {
            if(cnt == L) {
                int count = 0;
                String ans = "";
                for(int i=0;i<C;i++) {
                    if(check[i]) {
                        ans += arr[i];
                        if(str.contains(arr[i]+"")) {
                            count++;
                        }
                    }
                }
                if(L-count >= 2 && count >= 1)
                    System.out.println(ans);
    
                return;
            }
            if(target == C)
                return;
    
            check[target] = true;
            comb(target+1, cnt+1);
            check[target] = false;
            comb(target+1, cnt);
        }
    }
    
    ```
    
- SWEA 5215 햄버거 다이어트 - [S5215*햄버거다이어트*김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S5215_%ED%96%84%EB%B2%84%EA%B1%B0%EB%8B%A4%EC%9D%B4%EC%96%B4%ED%8A%B8_%EA%B9%80%EC%A4%91%EC%9E%AC.java)
    
    로직
    
    1. 부분 집합의 모든 경우를 생각해보기.
    2. 해당 경우의 수의 칼로리 합이 제한 칼로리보다 작은 경우에만 max값 비교
    3. max 출력
    생각못한점
    0/1knapsack으로 풀 수도 있음,,!
        
        ```
        
        package month10.study.week1;
        
        import java.util.Scanner;
        
        public class SWEA_햄버거다이어트 {
            static int T,N,L,max;
            static Node[] arr;
            static boolean[] check;
        
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                T = sc.nextInt();
                for(int tc=1;tc<=T;tc++) {
                    N = sc.nextInt();
                    L = sc.nextInt();
                    max = Integer.MIN_VALUE;
                    arr = new Node[N];
                    check = new boolean[N];
        
                    for(int i=0;i<N;i++) {
                        arr[i] = new Node(sc.nextInt(), sc.nextInt());
                    }
                    // 입력 완료
        
                    /* 로직 시작 */
                    comb(0);
        
                    System.out.println("#" + tc + " " + max);
                }
            }
        
            private static void comb(int target) {
                if(target == N) {
                    int sum = 0;
                    int kSum = 0;
                    boolean isOver = false;
                    for(int i=0;i<N;i++) {
                        if(check[i]) {
                            sum += arr[i].score;
                            kSum += arr[i].k;
                            if(kSum > L) {
                                isOver = true;
                                break;
                            }
                        }
                    }
                    if(!isOver) {
                        max = Math.max(max, sum);
                    }
        
                    return;
                }
        
                check[target] = true;
                comb(target+1);
                check[target] = false;
                comb(target+1);
            }
        
            private static class Node{
                int score;
                int k;
        
                public Node(int score, int k) {
                    super();
                    this.score = score;
                    this.k = k;
                }
            }
        }
        
        ```
        

### **정은이**

- 프로그래머스 가장 긴 팬린드롬 레벨 3 - [P12904*가장긴팰린드롬*정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%2012904%20%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC/P12904_%EA%B0%80%EC%9E%A5%EA%B8%B4%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC_%EC%A0%95%EC%9D%80%EC%9D%B4.java)
    
    🌊**문제 풀이 컨셉**
    
    1. 홀수 길이의 팰린드롬 자신을 기준으로 앞 뒤 체크
        
        `i` ⇒ `i-1 == i+1` ⇒ `(i-1)-1 == (i+1)+1`
        
    2. 짝수 길이의 팰린드롬 `i == i+1` ⇒ `i-1==(i+1)+1`
    3. 모든 자리 체크
        
        ```
        package programmers;
        
        public class Solution_가장긴팰린드롬 {
            public int solution(String s)
            {
                int max = 1;
                for(int c=0; c<s.length()-1;c++){
                    if(s.charAt(c)==s.charAt(c+1)) max = Math.max(even(c, s),max);
                    if(c>0 &&s.charAt(c-1)==s.charAt(c+1)) max = Math.max(odd(c, s),max);
                }
                return max;
            }
        
            public int odd(int c, String s){
                int p=1;
                int i=c-1;
                int j=c+1;
                while(true){
                    if(i<0 || j>= s.length()) break;
                    if(s.charAt(i)==s.charAt(j)){
                        p+=2;
                        i--;
                        j++;
                    } else break;
                }
                return p;
            }
            public int even(int c, String s){
                int p=0;
                int i=c;
                int j=c+1;
                while(true){
                    if(i<0 || j>= s.length()) break;
                    if(s.charAt(i)==s.charAt(j)){
                        p+=2;
                        i--;
                        j++;
                    } else break;
                }
                return p;
            }
        }
        ```
        
- 백준 3109 빵집 - [B3109*빵집*정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/B3109_%EB%B9%B5%EC%A7%91_%EC%A0%95%EC%9D%80%EC%9D%B4.java)
    
    오답 노트❓
    
    - **오답 ver1 그리디적인 접근을 해야한다**
        
        ```
        import java.io.BufferedReader;
        import java.io.IOException;
        import java.io.InputStreamReader;
        import java.util.StringTokenizer;
        
        public class Java_3109 {
            public static void main(String[] args) throws IOException {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st = new StringTokenizer(br.readLine());
                int R = Integer.parseInt(st.nextToken());
                int C = Integer.parseInt(st.nextToken());
                char[][] map = new char[R][C];
                boolean[][] checked = new boolean[R][C];
                int cnt=0;
        
                for (int i = 0; i < R; i++) {
                    map[i] = br.readLine().toCharArray();
                }
        
                int[] deltaX = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
        
                pipe:for (int i = 0; i < R; i++) {
                    int x = i;
        
                   line: for (int j = C - 2; j >= 0; j--) {
                        for (int d = 0; d < 3; d++) {
                            int tempX = x + deltaX[d];
                            if (tempX < 0 || tempX >= R ||map[tempX][j]=='x') {
                                if (d == 2) continue pipe;
                                continue;//범위 밖으로 나갈시에 continue
                            }
        
                            if(!checked[tempX][j]){
                                x=tempX;
                                checked[x][j]=true;
                                if(j==0) cnt++;
                                continue  line;
                            }
                        }
                    }
                }
                System.out.print(cnt);
        
            }
        }
        ```
        
    - **오답 ver2 백트래킹에서 함부로 return**
        
        ```
        import java.io.BufferedReader;
        import java.io.IOException;
        import java.io.InputStreamReader;
        import java.util.StringTokenizer;
        
        public class Main {
            static char[][] map;
            static int[] dx = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
        
            static int R,C;
            public static void main(String[] args) throws IOException {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
                StringTokenizer st = new StringTokenizer(br.readLine());
                R = Integer.parseInt(st.nextToken());
                C = Integer.parseInt(st.nextToken());
                map = new char[R][C];
                int cnt =0;
                for (int i = 0; i < R; i++) {
                    map[i] = br.readLine().toCharArray();
                }
        
                for (int i = 0; i <R ; i++) {
                    cnt+=dfs(i,0);
                }
                System.out.print(cnt);
        
            }
            public static int dfs( int i, int j){
                // r 은 시작 행 번호 , i ,j 위치, cnt는 갯수
                if(j==C-1) return 1;// 오른쪽 끝에 도착했으므로 cnt 증가
        
                for (int d = 0; d < 3; d++) {
                    int ti = i+dx[d];
                    int tj = j+1;
                    if(ti>=0 && ti<R && tj<C && map[ti][tj]=='.') {
                        // 유효 범위이고 가스관을 설치할 수 있으면
                        map[ti][tj]='x';
                        **return dfs(ti,tj);**
                    }
                }
                // 오른쪽으로 갈곳이 없다면, 그 다음행 가스관 설치 시작.
                return 0;
            }
        }
        ```
        
    - 틀린 이유
        - **백트래킹에서 함부로 return 하지 말자.**
        - **그리디적인 접근이 필요하다**
    
    **정답 코드**
    
    ```
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Main {
        static char[][] map;
        static int[] dx = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
    
        static int R,C;
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            StringTokenizer st = new StringTokenizer(br.readLine());
            R = Integer.parseInt(st.nextToken());
            C = Integer.parseInt(st.nextToken());
            map = new char[R][C];
            int cnt =0;
            for (int i = 0; i < R; i++) {
                map[i] = br.readLine().toCharArray();
            }
    
            for (int i = 0; i <R ; i++) {
                cnt+=dfs(i,0);
            }
            System.out.print(cnt);
    
        }
        public static int dfs( int i, int j){
            // i , j 위치
            if(j==C-1) return 1;// 오른쪽 끝에 도착했으므로 cnt 증가
    
            for (int d = 0; d < 3; d++) {
                int ti = i+dx[d];
                int tj = j+1;
                if(ti>=0 && ti<R && tj<C && map[ti][tj]=='.') {
                    // 유효 범위이고 가스관을 설치할 수 있으면
                    map[ti][tj]='x';
                    **// return dfs(ti,tj); // 이렇게 하면 다음 재귀에서 실패했을때 백트래킹을 못함.
                    if(dfs(ti,tj) == 1) return 1;**
                }
            }
            // 오른쪽으로 갈곳이 없다면, 그 다음행 가스관 설치 시작.
            return 0;
        }
    }
    ```
    

### **황승연**

- 백준 마법사 상어와 블리자드 골드2 - [B21611*마법사상어와블리자드*황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B0%B1%EC%A4%80%2021611%20%EB%A7%88%EB%B2%95%EC%82%AC%20%EC%83%81%EC%96%B4%EC%99%80%20%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C/B21611_%EB%A7%88%EB%B2%95%EC%82%AC%EC%83%81%EC%96%B4%EC%99%80%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
    
    백준 21611 마법사 상어와 블리자드 
    N이 홀수인 2차원 배열 [N](https://www.notion.so/19d8073fb6394795af9eb72d319c2789)에서 가운데에 상어가 있고 상어에서부터 달팽이처럼 돌면서 숫자가 채워지는데 이부분을 나는 0,0을 (N*N)-1로 놓고 바깥에서 안쪽으로 거꾸로 인덱스를 채워주었다. 
    또한 상어부터 인덱스 증가하는 방향으로 구슬을 채워줘야 했는데 스택을 사용하면 먼저 들어간 숫자가 나중에 나오니까 그 부분을 이용해서 구슬을 리스트에 채워주는 방식으로 접근했다. 
    그 이후에는 그냥 문제에서 주어진 대로 구현하면 되는데 구현을 마치고 테스트케이스까지 맞는 것을 확인하여 채점을 돌려봤는데 60%에서 틀렸습니다를 확인했다. 어디가 잘못되었는지 고치려고 계속 디버깅을 해보았지만 몇시간을 해도 찾을 수가 없었다.. 문제에서 주어진 조건 그대로를 모두 구현해야 한다는 것이 이 문제의 어려운 점 같다.
    
- SWEA 1210 사다리 - [S1210*사다리*황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S1210_%EC%82%AC%EB%8B%A4%EB%A6%AC_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
    
    ```
    package practice;
    
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Swea_1210_사다리 {
    
        static int[] di = {0,0,-1};         //밑에서부터 위로 찾아가므로 아래방향은 없음
        static int[] dj = {-1,1,0};
        static int[][] map;
        public static void main(String[] args) throws NumberFormatException, IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    
            for(int tc=1;tc<=10;tc++) {
                int T = Integer.parseInt(br.readLine());
    
                int nowi=-1;
                int nowj=-1;
    
                map = new int[100][100];
                for(int i=0;i<100;i++) {
                    StringTokenizer st = new StringTokenizer(br.readLine());
                    for(int j=0;j<100;j++) {
                        map[i][j] = Integer.parseInt(st.nextToken());
                        if(map[i][j]==2) {          //출발하는 곳
                            nowi =i;
                            nowj = j;
                        }
                    }
                }
    
                boolean[][] visited = new boolean[100][100];        //방문체크
    
                while(true) {
                    if(nowi==0) {                   //i가 0이면 도착이므로 break;
                        break;
                    }
                    visited[nowi][nowj] = true;
    
                    int nexti = -1;
                    int nextj = -1;
    
                    for(int d=0;d<3;d++) {                  //위랑 좌우 살피기
                        nexti = nowi+di[d];
                        nextj = nowj+dj[d];
    
                        if(nexti<0 || nextj<0 || nexti>=100 || nextj>=100) {            //배열범위 벗어나면 컨티뉴
                            continue;
                        }
    
                        if(!visited[nexti][nextj] &&map[nexti][nextj]==1 ) {            //방문하지 않았고 갈수있다면 방향탐색마치기
                            break;
                        }
                    }
    
                    nowi = nexti;               //다음위치로
                    nowj = nextj;
                }
                System.out.println("#"+tc+" "+nowj);
            }
    
        }
    }
    ```
    
- SWEA 1218 괄호짝짓기 - [S1218*괄호짝짓기*황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1%EC%A3%BC%EC%B0%A8/%EB%B3%B5%EC%8A%B5%20%EB%AC%B8%EC%A0%9C/S1218_%EA%B4%84%ED%98%B8%EC%A7%9D%EC%A7%93%EA%B8%B0_%ED%99%A9%EC%8A%B9%EC%97%B0.java)
    
    ```
    package practice;
    
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.Stack;
    
    public class Swea_1218_괄호짝짓기 {
    
        static String open = "({[<";                //여는괄호
        static String close = ")}]>";               //닫는 괄호
        public static void main(String[] args) throws NumberFormatException, IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    
            for(int tc=1;tc<=10;tc++) {
                int num = Integer.parseInt(br.readLine());
    
                String str = br.readLine();
    
                Stack<String> stack = new Stack<>();            //여는괄호를 만나면 스택에 넣어주기 위해 스택생성
    
                boolean flag = true;                            //여는괄호와 닫는괄호가 짝이 다 맞는지 판별하기위한 불린변수
    
                for(int i=0;i<num;i++) {
                    String one = str.substring(i, i+1);         //하나씩 꺼내서
    
                    if(open.contains(one)) {                    //여는괄호면
                        stack.push(one);                        //스택에 넣기
                    }else if(!stack.isEmpty()) {                //닫는괄호고 스택이 비어있지 않다면
                        String get = stack.pop();               //가장 최근에 스택으로 들어간 여는 괄호 꺼내기
                        if(open.indexOf(get)!=close.indexOf(one)) {         //짝이 안맞는 경우
                            flag = false;                       //짝안맞음
                            break;                          //더 볼 필요도 없다
                        }
                    }else {                                 //닫는괄호가 스택이 비어있다면
                        flag =false;                        //짝 안맞음
                        break;                              //더 볼필요 없음
                    }
    
                }
                if(!stack.isEmpty()) {          //개수가 안맞는 경우
                    flag = false;               //안맞음
                }
    
                if(flag) {
                    System.out.println("#"+tc+" 1");
                }else {
                    System.out.println("#"+tc+" 0");
                }
    
            }
    
        }
    
    }
    ```
    

### **스터디 사진**

![https://user-images.githubusercontent.com/51378843/136701970-78720898-6d8b-423f-8fd2-663fb94b3f57.png](https://user-images.githubusercontent.com/51378843/136701970-78720898-6d8b-423f-8fd2-663fb94b3f57.png)

### **오픈 카톡방 폭파**

![https://user-images.githubusercontent.com/51378843/136702073-56d36f11-4334-4579-a29b-7dd9ef36c6a6.PNG](https://user-images.githubusercontent.com/51378843/136702073-56d36f11-4334-4579-a29b-7dd9ef36c6a6.PNG)
