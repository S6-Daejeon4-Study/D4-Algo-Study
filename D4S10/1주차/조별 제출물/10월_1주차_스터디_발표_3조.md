# 10월 1주차 스터디 - 3C

**발표일자** : 2021년 10월 8일 금요일 21:00~ 22:00

목차

[TOC]

------

**알고리즘 문제 ( 기출 + 복습)**

- 기출 
- [백준 마법사 상어와 블리자드 골드2](https://www.acmicpc.net/problem/21611) - 김응철 , [황승연](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/백준 21611 마법사 상어와 블리자드/B21611_마법사상어와블리자드_황승연.java)
  - [프로그래머스 가장 긴 팬린드롬 레벨 3]( https://programmers.co.kr/learn/courses/30/lessons/12904) -  [김중재](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/프로그래머스 12904 가장 긴 팰린드롬/P12904_가장긴팰린드롬_김중재.java), [정은이]( [P12904_가장긴팰린드롬_정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/프로그래머스 12904 가장 긴 팰린드롬/P12904_가장긴팰린드롬_정은이.java))  
- 복습
  - 김응철
    -  [백준 10026 적록색약](https://www.acmicpc.net/problem/10026) - [B10026_적록색약_김응철.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B10026_적록색약_김응철.java)
  - 김중재
    - [백준 1759 암호만들기](https://www.acmicpc.net/problem/1759)  -  [B1759_암호만들기_김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B1759_암호만들기_김중재.java)
    - [SWEA 5215 햄버거 다이어트](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=5215&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S5215_햄버거다이어트_김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S5215_햄버거다이어트_김중재.java)
  - 황승연
    - [SWEA 1210 사다리](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=1210&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S1210_사다리_황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S1210_사다리_황승연.java)
    - [SWEA 1218 괄호짝짓기](https://swexpertacademy.com/main/code/problem/problemList.do?contestProbId=&categoryId=&categoryType=&problemTitle=1218&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1#none) - [S1218_괄호짝짓기_황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S1218_괄호짝짓기_황승연.java)
  - 정은이
    - [백준 3109 빵집](https://www.acmicpc.net/problem/3109) - [B3109_빵집_정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B3109_빵집_정은이.java)

****



### 발표

 ##### 김응철

- 백준 마법사 상어와 블리자드 골드2

  문제풀이 계획

- 백준 10026 적록색약 - [B10026_적록색약_김응철.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B10026_적록색약_김응철.java)

  < 이전 풀이> 
  한달전쯤에 find union 을 이용하여 시도했다가 실패했던 문제입니다
  모두가 각자의 부모인 parent 이차원배열을 만들어서
  이중 for 문으로 배열을 탐색하다 visit 하지 않은 칸을 만나면 그곳을 parents 로 시작하여 주변에 입력값이 같은 배열요소들을 find 하여 union 시키는 방식이었습니다.
  테스트케이스는 나왔지만 백준에서 돌렸을 땐 계속해서 실패했었어서 다음을 기약했는데 이번에 다른 방식으로 풀어봤습니다.

  < 이번 풀이 >
  이중 for 문을 돌면서 map 배열을 탐색하는 것은 같지만
  point 객체를 이용하여 v isit 하지 않은 곳부터 bfs 로 탐색하며 visit 체크를 해준다는 점이 다릅니다
  bfs 를 이용하여 풀이하니 보다 직관적이고 복잡하지 않게 코드를 짤 수 있어서 좋았습니다.

 #####  김중재

- 프로그래머스 가장 긴 팬린드롬 레벨 3 - [P12904_가장긴팰린드롬_김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/프로그래머스 12904 가장 긴 팰린드롬/P12904_가장긴팰린드롬_김중재.java)

  문제 풀이 컨셉
  1. 재귀로 접근
  2. 가운데 기준으로 하는거(길이가 홀수인 팰린드롬)랑 아닌거(길이가 짝수인 팰린드롬)랑 나누기.
  3. 0번쨰 인덱스부터 크기(size)-1 까지 돌면서 홀수인 경우 짝수인 경우 중 큰거로 answer 업데이트
  4. answer 출력

  맨 처음 "abba" 의 경우를 생각 못하고
  테스트케이스 처럼 가운데 기준으로 앞뒤가 같은것만 갯수 세고 있었음

  ```java
  public class Programmers_가장긴팰린드롬 {
  	static char[] str;
  	static int cnt;
  	
  	public static void main(String[] args) {
  		System.out.println(solution("abba"));
  	}
  
  	public static int solution(String s)
      {
          int answer = Integer.MIN_VALUE;
          if(s.length() == 1) {
          	return 1;
          }
          str = s.toCharArray();
  
          for(int i=0;i<str.length-1;i++) {
          	cnt = 0;
          	answer = Math.max(answer, check(i-1,i+1) * 2 +1);
          	cnt = 0;
          	answer = Math.max(answer, check(i,i+1) * 2);
          }
  
          return answer;
      }
  
  	private static int check(int bNum, int nNum) {
  		if(bNum == -1 || nNum == str.length || str[bNum] != str[nNum])
  			return cnt;
  		cnt++;
  		check(bNum-1,nNum+1);
  		return cnt;
  	}
  }
  ```

- 백준 1759 암호만들기  -  [B1759_암호만들기_김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B1759_암호만들기_김중재.java)

  로직

  1. 오름차순 정렬 후 조합의 경우의 수를 구해서 문제에서 제시한 조건에 부합하는지 확인
  a. 모음의 수를 카운트함. → contains함수 사용
  b. 모음의 수가 1이상이고 L-모음의 수가 2이상인지 확인
  2. 조건에 부합하면 해당하는 경우를 출력

  ```java
  package month10.study.week1;
  
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.Arrays;
  import java.util.StringTokenizer;
  
  public class BOJ_1759_암호만들기 {
  	static int L,C;
  	static char[] arr;
  	static boolean[] check;
  	static String str = "aeiou";
  	
  	public static void main(String[] args) throws IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		StringTokenizer st = new StringTokenizer(br.readLine()," ");
  		L = Integer.parseInt(st.nextToken());
  		C = Integer.parseInt(st.nextToken());
  		arr = new char[C];
  		check = new boolean[C];
  		
  		st = new StringTokenizer(br.readLine()," ");
  		for(int i=0;i<C;i++) {
  			arr[i] = st.nextToken().charAt(0);
  		}
  		// 입력 완료
  		
  		Arrays.sort(arr);
  		
  		comb(0,0);
  	}
  
  	private static void comb(int target, int cnt) {
  		if(cnt == L) {
  			int count = 0;
  			String ans = "";
  			for(int i=0;i<C;i++) {
  				if(check[i]) {
  					ans += arr[i];
  					if(str.contains(arr[i]+"")) {
  						count++;
  					}
  				}
  			}
  			if(L-count >= 2 && count >= 1)
  				System.out.println(ans);
  			
  			return;
  		}
  		if(target == C)
  			return;
  		
  		check[target] = true;
  		comb(target+1, cnt+1);
  		check[target] = false;
  		comb(target+1, cnt);
  	}
  }
  
  ```

- SWEA 5215 햄버거 다이어트 - [S5215_햄버거다이어트_김중재.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S5215_햄버거다이어트_김중재.java)

  로직
  1. 부분 집합의 모든 경우를 생각해보기.

  2. 해당 경우의 수의 칼로리 합이 제한 칼로리보다 작은 경우에만 max값 비교

  3. max 출력
    생각못한점
    0/1knapsack으로 풀 수도 있음,,!

    ```java
    
    package month10.study.week1;
    
    import java.util.Scanner;
    
    public class SWEA_햄버거다이어트 {
    	static int T,N,L,max;
    	static Node[] arr;
    	static boolean[] check;
    	
    	public static void main(String[] args) {
    		Scanner sc = new Scanner(System.in);
    		T = sc.nextInt();
    		for(int tc=1;tc<=T;tc++) {
    			N = sc.nextInt();
    			L = sc.nextInt();
    			max = Integer.MIN_VALUE;
    			arr = new Node[N];
    			check = new boolean[N];
    			
    			for(int i=0;i<N;i++) {
    				arr[i] = new Node(sc.nextInt(), sc.nextInt());
    			}
    			// 입력 완료
    			
    			/* 로직 시작 */
    			comb(0);
    			
    			System.out.println("#" + tc + " " + max);
    		}
    	}
    	
    	private static void comb(int target) {
    		if(target == N) {
    			int sum = 0;
    			int kSum = 0;
    			boolean isOver = false;
    			for(int i=0;i<N;i++) {
    				if(check[i]) {
    					sum += arr[i].score;
    					kSum += arr[i].k;
    					if(kSum > L) {
    						isOver = true;
    						break;
    					}
    				}
    			}
    			if(!isOver) {
    				max = Math.max(max, sum);
    			}
    			
    			return;
    		}
    		
    		check[target] = true;
    		comb(target+1);
    		check[target] = false;
    		comb(target+1);
    	}
    
    	private static class Node{
    		int score;
    		int k;
    		
    		public Node(int score, int k) {
    			super();
    			this.score = score;
    			this.k = k;
    		}
    	}
    }
    
    ```

##### 정은이

- 프로그래머스 가장 긴 팬린드롬 레벨 3 - [P12904_가장긴팰린드롬_정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/프로그래머스 12904 가장 긴 팰린드롬/P12904_가장긴팰린드롬_정은이.java)

  🌊**문제 풀이 컨셉**

  1. 홀수 길이의 팰린드롬 자신을 기준으로 앞 뒤 체크

     `i` ⇒ `i-1 == i+1` ⇒ `(i-1)-1 == (i+1)+1`

  2. 짝수 길이의 팰린드롬 `i == i+1` ⇒ `i-1==(i+1)+1`

  3. 모든 자리 체크

     ```java
     package programmers;
     
     public class Solution_가장긴팰린드롬 {
         public int solution(String s)
         {
             int max = 1;
             for(int c=0; c<s.length()-1;c++){
                 if(s.charAt(c)==s.charAt(c+1)) max = Math.max(even(c, s),max);
                 if(c>0 &&s.charAt(c-1)==s.charAt(c+1)) max = Math.max(odd(c, s),max);
             }
             return max;
         }
     
         public int odd(int c, String s){
             int p=1;
             int i=c-1;
             int j=c+1;
             while(true){
                 if(i<0 || j>= s.length()) break;
                 if(s.charAt(i)==s.charAt(j)){
                     p+=2;
                     i--;
                     j++;
                 } else break;
             }
             return p;
         }
         public int even(int c, String s){
             int p=0;
             int i=c;
             int j=c+1;
             while(true){
                 if(i<0 || j>= s.length()) break;
                 if(s.charAt(i)==s.charAt(j)){
                     p+=2;
                     i--;
                     j++;
                 } else break;
             }
             return p;
         }
     }
     ```

- 백준 3109 빵집 - [B3109_빵집_정은이.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/B3109_빵집_정은이.java)

  오답 노트❓

  - **오답 ver1 그리디적인 접근을 해야한다**

    ```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Java_3109 {
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            StringTokenizer st = new StringTokenizer(br.readLine());
            int R = Integer.parseInt(st.nextToken());
            int C = Integer.parseInt(st.nextToken());
            char[][] map = new char[R][C];
            boolean[][] checked = new boolean[R][C];
            int cnt=0;
    
            for (int i = 0; i < R; i++) {
                map[i] = br.readLine().toCharArray();
            }
    
            int[] deltaX = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
    
            pipe:for (int i = 0; i < R; i++) {
                int x = i;
    
               line: for (int j = C - 2; j >= 0; j--) {
                    for (int d = 0; d < 3; d++) {
                        int tempX = x + deltaX[d];
                        if (tempX < 0 || tempX >= R ||map[tempX][j]=='x') {
                            if (d == 2) continue pipe;
                            continue;//범위 밖으로 나갈시에 continue
                        }
    
                        if(!checked[tempX][j]){
                            x=tempX;
                            checked[x][j]=true;
                            if(j==0) cnt++;
                            continue  line;
                        }
                    }
                }
            }
            System.out.print(cnt);
    
        }
    }
    ```

  - **오답 ver2 백트래킹에서 함부로 return**

    ```java
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Main {
        static char[][] map;
        static int[] dx = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
    
        static int R,C;
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            StringTokenizer st = new StringTokenizer(br.readLine());
            R = Integer.parseInt(st.nextToken());
            C = Integer.parseInt(st.nextToken());
            map = new char[R][C];
            int cnt =0;
            for (int i = 0; i < R; i++) {
                map[i] = br.readLine().toCharArray();
            }
    
            for (int i = 0; i <R ; i++) {
                cnt+=dfs(i,0);
            }
            System.out.print(cnt);
    
        }
        public static int dfs( int i, int j){
            // r 은 시작 행 번호 , i ,j 위치, cnt는 갯수
            if(j==C-1) return 1;// 오른쪽 끝에 도착했으므로 cnt 증가
    
            for (int d = 0; d < 3; d++) {
                int ti = i+dx[d];
                int tj = j+1;
                if(ti>=0 && ti<R && tj<C && map[ti][tj]=='.') {
                    // 유효 범위이고 가스관을 설치할 수 있으면
                    map[ti][tj]='x';
                    **return dfs(ti,tj);**
                }
            }
            // 오른쪽으로 갈곳이 없다면, 그 다음행 가스관 설치 시작. 
            return 0;
        }
    }
    ```

  - 틀린 이유

    - **백트래킹에서 함부로 return 하지 말자.**
    - **그리디적인 접근이 필요하다**

  **정답 코드** 

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;
  
  public class Main {
      static char[][] map;
      static int[] dx = {-1, 0, 1}; // 왼쪽 대각선 위 , 직진, 왼쪽쪽 대각선 아래
  
      static int R,C;
      public static void main(String[] args) throws IOException {
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          StringTokenizer st = new StringTokenizer(br.readLine());
          R = Integer.parseInt(st.nextToken());
          C = Integer.parseInt(st.nextToken());
          map = new char[R][C];
          int cnt =0;
          for (int i = 0; i < R; i++) {
              map[i] = br.readLine().toCharArray();
          }
  
          for (int i = 0; i <R ; i++) {
              cnt+=dfs(i,0);
          }
          System.out.print(cnt);
  
      }
      public static int dfs( int i, int j){
          // i , j 위치
          if(j==C-1) return 1;// 오른쪽 끝에 도착했으므로 cnt 증가
  
          for (int d = 0; d < 3; d++) {
              int ti = i+dx[d];
              int tj = j+1;
              if(ti>=0 && ti<R && tj<C && map[ti][tj]=='.') {
                  // 유효 범위이고 가스관을 설치할 수 있으면
                  map[ti][tj]='x';
                  **// return dfs(ti,tj); // 이렇게 하면 다음 재귀에서 실패했을때 백트래킹을 못함.
                  if(dfs(ti,tj) == 1) return 1;**
              }
          }
          // 오른쪽으로 갈곳이 없다면, 그 다음행 가스관 설치 시작.
          return 0;
      }
  }
  ```

##### 황승연

- 백준 마법사 상어와 블리자드 골드2 - [B21611_마법사상어와블리자드_황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/백준 21611 마법사 상어와 블리자드/B21611_마법사상어와블리자드_황승연.java)

  백준 21611 마법사 상어와 블리자드 
  N이 홀수인 2차원 배열 [N][N]에서 가운데에 상어가 있고 상어에서부터 달팽이처럼 돌면서 숫자가 채워지는데 이부분을 나는 0,0을 (N*N)-1로 놓고 바깥에서 안쪽으로 거꾸로 인덱스를 채워주었다. 
  또한 상어부터 인덱스 증가하는 방향으로 구슬을 채워줘야 했는데 스택을 사용하면 먼저 들어간 숫자가 나중에 나오니까 그 부분을 이용해서 구슬을 리스트에 채워주는 방식으로 접근했다. 
  그 이후에는 그냥 문제에서 주어진 대로 구현하면 되는데 구현을 마치고 테스트케이스까지 맞는 것을 확인하여 채점을 돌려봤는데 60%에서 틀렸습니다를 확인했다. 어디가 잘못되었는지 고치려고 계속 디버깅을 해보았지만 몇시간을 해도 찾을 수가 없었다.. 문제에서 주어진 조건 그대로를 모두 구현해야 한다는 것이 이 문제의 어려운 점 같다.

- SWEA 1210 사다리 - [S1210_사다리_황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S1210_사다리_황승연.java)

  ```java
  package practice;
  
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.StringTokenizer;
  
  public class Swea_1210_사다리 {
  
  	static int[] di = {0,0,-1};			//밑에서부터 위로 찾아가므로 아래방향은 없음
  	static int[] dj = {-1,1,0};
  	static int[][] map;
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		
  		for(int tc=1;tc<=10;tc++) {
  			int T = Integer.parseInt(br.readLine());
  			
  			int nowi=-1;
  			int nowj=-1;
  			
  			map = new int[100][100];
  			for(int i=0;i<100;i++) {
  				StringTokenizer st = new StringTokenizer(br.readLine());
  				for(int j=0;j<100;j++) {
  					map[i][j] = Integer.parseInt(st.nextToken());
  					if(map[i][j]==2) {			//출발하는 곳
  						nowi =i;
  						nowj = j;
  					}
  				}
  			}
  			
  			boolean[][] visited = new boolean[100][100];		//방문체크
  			
  			while(true) {
  				if(nowi==0) {					//i가 0이면 도착이므로 break;
  					break;
  				}
  				visited[nowi][nowj] = true;
  				
  				int nexti = -1;
  				int nextj = -1;
  				
  				for(int d=0;d<3;d++) {					//위랑 좌우 살피기
  					nexti = nowi+di[d];
  					nextj = nowj+dj[d];
  					
  					if(nexti<0 || nextj<0 || nexti>=100 || nextj>=100) {			//배열범위 벗어나면 컨티뉴
  						continue;
  					}
  					
  					if(!visited[nexti][nextj] &&map[nexti][nextj]==1 ) {			//방문하지 않았고 갈수있다면 방향탐색마치기
  						break;
  					}
  				}
  				
  				nowi = nexti;				//다음위치로
  				nowj = nextj;
  			}
  			System.out.println("#"+tc+" "+nowj);
  		}
  
  	}
  }
  ```

- SWEA 1218 괄호짝짓기 - [S1218_괄호짝짓기_황승연.java](https://github.com/S6-Daejeon4-Study/D4-Algo-Study/blob/main/D4S10/1주차/복습 문제/S1218_괄호짝짓기_황승연.java)

  ```javascript
  package practice;
  
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.util.Stack;
  
  public class Swea_1218_괄호짝짓기 {
  
  	static String open = "({[<";				//여는괄호
  	static String close = ")}]>";				//닫는 괄호
  	public static void main(String[] args) throws NumberFormatException, IOException {
  		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  		
  		for(int tc=1;tc<=10;tc++) {
  			int num = Integer.parseInt(br.readLine());
  			
  			String str = br.readLine();
  			
  			Stack<String> stack = new Stack<>();			//여는괄호를 만나면 스택에 넣어주기 위해 스택생성
  			
  			boolean flag = true;							//여는괄호와 닫는괄호가 짝이 다 맞는지 판별하기위한 불린변수
  			
  			for(int i=0;i<num;i++) {
  				String one = str.substring(i, i+1);			//하나씩 꺼내서
  				
  				if(open.contains(one)) {					//여는괄호면
  					stack.push(one);						//스택에 넣기
  				}else if(!stack.isEmpty()) {				//닫는괄호고 스택이 비어있지 않다면
  					String get = stack.pop();				//가장 최근에 스택으로 들어간 여는 괄호 꺼내기
  					if(open.indexOf(get)!=close.indexOf(one)) {			//짝이 안맞는 경우
  						flag = false;						//짝안맞음
  						break;							//더 볼 필요도 없다
  					}
  				}else {									//닫는괄호가 스택이 비어있다면
  					flag =false;						//짝 안맞음
  					break;								//더 볼필요 없음
  				}
  				
  			}
  			if(!stack.isEmpty()) {			//개수가 안맞는 경우
  				flag = false;				//안맞음
  			}
  			
  			if(flag) {
  				System.out.println("#"+tc+" 1");
  			}else {
  				System.out.println("#"+tc+" 0");
  			}
  			
  			
  		}
  
  	}
  
  }
  ```

### 스터디 사진

![KakaoTalk_20211008_214623666](https://user-images.githubusercontent.com/51378843/136701970-78720898-6d8b-423f-8fd2-663fb94b3f57.png)

### 오픈 카톡방 폭파 

![openkakao](https://user-images.githubusercontent.com/51378843/136702073-56d36f11-4334-4579-a29b-7dd9ef36c6a6.PNG)
)